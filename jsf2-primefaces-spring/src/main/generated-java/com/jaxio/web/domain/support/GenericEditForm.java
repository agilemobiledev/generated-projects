/*
 * (c) Copyright 2005-2013 JAXIO, http://www.jaxio.com
 * Source code generated by Celerio, a Jaxio product
 * Want to use Celerio within your company? email us at info@jaxio.com
 * Follow us on twitter: @springfuse
 * Template pack-jsf2-spring:src/main/java/domain/support/GenericEditForm.p.vm.java
 */
package com.jaxio.web.domain.support;

import java.io.Serializable;
import java.util.List;

import javax.inject.Inject;

import com.jaxio.dao.support.JpaUniqueUtil;
import com.jaxio.domain.Identifiable;
import com.jaxio.repository.support.Repository;
import com.jaxio.web.conversation.Conversation;
import com.jaxio.web.conversation.ConversationContext;
import com.jaxio.web.conversation.ConversationManager;
import com.jaxio.web.util.MessageUtil;
import com.jaxio.web.util.PrimeFacesUtil;

/**
 * Base Edit Form for JPA entities.
 */
public abstract class GenericEditForm<E extends Identifiable<PK>, PK extends Serializable> {
    @Inject
    protected JpaUniqueUtil jpaUniqueUtil;

    @Inject
    protected MessageUtil messageUtil;

    @Inject
    protected ConversationManager conversationManager;

    protected Repository<E, PK> repository;

    protected void setRepository(Repository<E, PK> repository) {
        this.repository = repository;
    }

    /**
     * Return the entity that this edit form backs.
     */
    abstract public E getEntity();

    // ------------------------------------
    // Actions
    // ------------------------------------

    /**
     * Ok action is used from sub page (non-readonly) to send the data without saving it. 
     * It is expected to be ajax since we want to display the errors, if any,
     * without refreshing the page.
     */
    public String ok() {
        return context().getCallBack().ok(getEntity());
    }

    /**
     * Close the current edit page, but check first if any unsaved data is pending.
     */
    public String close() {
        Conversation conversation = conversation();
        if (!PrimeFacesUtil.showAskForSaveDialog(conversation.getEntityManager(), getEntity())) {
            return context().getCallBack().back();
        }
        return null;
    }

    /**
     * Close the current edit page, without any dirty data checking.
     */
    public String forceClose() {
        return context().getCallBack().notSaved(getEntity());
    }

    /**
     * Back action is used from readonly page to go back. It is expected to be non-ajax.
     */
    public String back() {
        return context().getCallBack().back();
    }

    /**
     * Send action is used from main edit page. It is used to send the data without validating/saving it.
     */
    public void send() {
        messageUtil.info("status_submitted_ok");
    }

    /**
     * deleteAndClose action is used form modal dialogs in the main edit page. 
     */
    public String deleteAndClose() {
        E entity = getEntity();
        repository.delete(entity);
        messageUtil.infoEntity("status_deleted_ok", entity);
        return context().getCallBack().deleted(entity);
    }

    /**
     * Save action. Used from main edit page. Expected to be an ajax request.
     */
    public String saveAndClose() {
        if (saveAndCloseInternal(getEntity())) {
            return context().getCallBack().saved(getEntity());
        }
        return null;
    }

    protected boolean saveAndCloseInternal(E entity) {
        if (!validate(entity)) {
            return false;
        }
        repository.save(entity);
        messageUtil.infoEntity("status_saved_ok", entity);
        return true;
    }

    public boolean validate(E entity) {
        List<String> errors = jpaUniqueUtil.validateUniques(entity);
        for (String error : errors) {
            messageUtil.error(error);
        }
        return errors.isEmpty();
    }

    /**
     * Returns the current {@link Conversation}.
     */
    public Conversation conversation() {
        return conversationManager.getCurrentConversation();
    }

    /**
     * Returns the current {@link ConversationContext}.
     */
    public ConversationContext<E> context() {
        return conversationManager.getCurrentConversation().getCurrentContext();
    }
}
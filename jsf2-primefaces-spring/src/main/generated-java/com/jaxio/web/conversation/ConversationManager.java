/*
 * (c) Copyright 2005-2012 JAXIO, http://www.jaxio.com
 * Source code generated by Celerio, a Jaxio product
 * Want to use Celerio within your company? email us at info@jaxio.com
 * Follow us on twitter: @springfuse
 * Template pack-jsf2-spring:src/main/java/conversation/ConversationManager.p.vm.java
 */
package com.jaxio.web.conversation;

import static com.google.common.collect.Maps.newHashMap;

import java.util.Map;

import javax.faces.context.FacesContext;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import org.apache.commons.lang.StringUtils;
import org.primefaces.component.menuitem.MenuItem;
import org.primefaces.model.DefaultMenuModel;
import org.primefaces.model.MenuModel;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.orm.jpa.EntityManagerHolder;
import org.springframework.transaction.support.TransactionSynchronizationManager;

/**
 * The conversation manager is responsible for creating conversations and managing their state.
 */
public class ConversationManager implements ApplicationContextAware {
    private static final String CONVERSATION_MAP = "conversationMap";

    private Map<String, ConversationFactory> conversationFactories = newHashMap();
    private EntityManagerFactory entityManagerFactory;
    private ApplicationContext applicationContext;

    private int maxConversations;

    private static ConversationManager instance;

    private ThreadLocal<Conversation> currentConversation = new ThreadLocal<Conversation>();

    public ConversationManager(EntityManagerFactory entityManagerFactory, int maxConversations) {
        this.entityManagerFactory = entityManagerFactory;
        this.maxConversations = maxConversations;

        if (instance == null) {
            instance = this;
        }
    }

    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }

    /**
     * This method should be used only in the following cases: 1) from code having no spring awareness, like filters. 2) from code that are session scoped in order to avoid serialization of the service.
     * In other cases, please have the conversationManager injected normally. 
     */
    static public ConversationManager getInstance() {
        return instance;
    }

    /**
     * The maximum number of conversations a given user can open simultaneously. 
     */
    public int getMaxConversations() {
        return maxConversations;
    }

    /**
     * Creates a new {@link Conversation}, binds a new entityManager and start the conversation.
     */
    public Conversation createConversation(HttpServletRequest request) {
        Conversation conversation = getFactoryByUri(request).create(request);
        EntityManager em = entityManagerFactory.createEntityManager();
        conversation.setEntityManager(em);
        conversationMap(request.getSession()).put(conversation.getId(), conversation);
        bind(em);
        conversation.start();
        currentConversation.set(conversation);
        return conversation;
    }

    /**
     * Remove the conversation whose id matches the passed id. Unbind and close the entityManager if the conversation was the current conversation.
     */
    public boolean removeConversation(String id) {
        Conversation conv = currentConversation.get();
        if (conv != null && StringUtils.equals(id, conv.getId())) {
            unbind(conv.getEntityManager());
            conv.getEntityManager().close();
        }
        currentConversation.set(null);
        return conversationMap().remove(id) != null;
    }

    public void resumeConversation(String id, HttpServletRequest request) throws UnexpectedConversationException {
        Conversation conversation = conversationMap(request.getSession()).get(id);

        if (conversation != null) {
            if (!request.getRequestURI().contains(conversation.getUri())) {
                throw new UnexpectedConversationException(request.getRequestURI(), conversation.getMenuUrl());
            }
            bind(conversation.getEntityManager());
            conversation.resume();
            currentConversation.set(conversation);
        } else {
            throw new UnexpectedConversationException(request.getRequestURI(), "/home.faces");
        }
    }

    public void pauseCurrentConversation() {
        Conversation conversation = currentConversation.get();
        if (conversation != null) {
            conversation.pause();
            unbind(conversation.getEntityManager());
            currentConversation.set(null);
        }
    }

    public Conversation getCurrentConversation() {
        return currentConversation.get();
    }

    /**
     * Returns the number of conversations for the current user.
     * Used in the conversation menu.
     */
    public int getConversationCount() {
        return conversationMap().size();
    }

    /**
     * Whether the max number of conversations per user is reached.
     * Used in from the ConversationFilter (which has no FacesContext yet).
     */
    public boolean isMaxConversationsReached(HttpSession session) {
        return conversationMap(session).size() >= maxConversations;
    }

    public MenuModel getConversationMenuModel() {
        MenuModel model = new DefaultMenuModel();
        Conversation current = getCurrentConversation();
        for (Conversation conversation : conversationMap().values()) {
            MenuItem htmlMenuItem = new MenuItem();
            htmlMenuItem.setValue(conversation.getLabel());
            htmlMenuItem.setUrl(conversation.getMenuUrl());
            if (current != null && current.getId().equals(conversation.getId())) {
                htmlMenuItem.setDisabled(true);
            }
            model.addMenuItem(htmlMenuItem);
        }
        return model;
    }

    private Map<String, Conversation> conversationMap() {
        @SuppressWarnings("unchecked")
        Map<String, Conversation> map = (Map<String, Conversation>) sessionMap().get(CONVERSATION_MAP);
        if (map == null) {
            map = newHashMap();
            sessionMap().put(CONVERSATION_MAP, map);
        }
        return map;
    }

    private Map<String, Conversation> conversationMap(HttpSession session) {
        @SuppressWarnings("unchecked")
        Map<String, Conversation> map = (Map<String, Conversation>) session.getAttribute(CONVERSATION_MAP);
        if (map == null) {
            map = newHashMap();
            session.setAttribute(CONVERSATION_MAP, map);
        }
        return map;
    }

    private Map<String, Object> sessionMap() {
        return FacesContext.getCurrentInstance().getExternalContext().getSessionMap();
    }

    private ConversationFactory getFactoryByUri(HttpServletRequest request) {
        String uri = request.getServletPath();
        ConversationFactory result = conversationFactories.get(uri);

        if (result == null) {
            for (ConversationFactory cf : applicationContext.getBeansOfType(ConversationFactory.class).values()) {
                if (cf.canCreate(request)) {
                    conversationFactories.put(uri, cf);
                    result = cf;
                }
            }
        }

        return result;
    }

    // --------------------------------------------
    // Extended Persistencve related
    // (same code as in spring web flow)
    // --------------------------------------------

    private void bind(EntityManager em) {
        TransactionSynchronizationManager.bindResource(entityManagerFactory, new EntityManagerHolder(em));
    }

    private void unbind(EntityManager em) {
        if (TransactionSynchronizationManager.hasResource(entityManagerFactory)) {
            TransactionSynchronizationManager.unbindResource(entityManagerFactory);
        }
    }
}

/*
 * (c) Copyright 2005-2013 JAXIO, http://www.jaxio.com
 * Source code generated by Celerio, a Jaxio product
 * Want to use Celerio within your company? email us at info@jaxio.com
 * Follow us on twitter: @springfuse
 * Template pack-jsf2-spring:src/main/java/conversation/ConversationScope.p.vm.java
 */
package com.jaxio.web.conversation;

import org.springframework.beans.factory.ObjectFactory;
import org.springframework.beans.factory.config.AutowireCapableBeanFactory;
import org.springframework.beans.factory.config.Scope;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

/**
 * Beans in the conversation scope reside in a {@link Conversation conversation}'s {@link ConversationContext}.
 * They are 'visible' only when the conversation is bound to the current Thread of execution and their 
 * hosting ConversationContext is on top of the conversation's contextes stack.
 * 
 * Such a design decision allows a conversation to have 2 'conversation scoped' beans with 
 * the same name (they just have to reside in 2 difference ConversationContext).
 * This prevents bean name clash in complex navigation scenario within the same conversation.
 */
public class ConversationScope implements Scope, ApplicationContextAware {
    private AutowireCapableBeanFactory autowireCapableBeanFactory;
    protected ConversationManager cm;

    public void setApplicationContext(ApplicationContext appCtx) {
        autowireCapableBeanFactory = appCtx.getAutowireCapableBeanFactory();
    }

    public void setConversationManager(ConversationManager cm) {
        this.cm = cm;
    }

    @Override
    public String getConversationId() {
        return cm.getCurrentConversation().getId();
    }

    @Override
    public Object get(String name, ObjectFactory<?> objectFactory) {
        Object bean = cm.getCurrentConversation().getBean(name);

        if (bean == null) {
            bean = objectFactory.getObject();
            cm.getCurrentConversation().addBean(name, bean);
            cm.getCurrentConversation().setVar("__" + name + "__wired", Boolean.TRUE);
        } else {
            // let's check if the bean has been wired.
            Boolean wired = cm.getCurrentConversation().getVar("__" + name + "__wired", Boolean.class);
            if (wired == null) {
                // bean was created manually. The creator expects us to wire it: 
                autowireCapableBeanFactory.autowireBean(bean);
                cm.getCurrentConversation().setVar("__" + name + "__wired", Boolean.TRUE);
            }
            // TODO: we could detect if bean was serialized in order to re-wire it... 
        }
        return bean;
    }

    @Override
    public Object remove(String name) {
        throw new UnsupportedOperationException("remove is done during conversation.end");
    }

    @Override
    public void registerDestructionCallback(String name, Runnable callback) {
        // no ops
    }

    @Override
    public Object resolveContextualObject(String key) {
        return cm.getCurrentConversation().getVar(key);
    }
}